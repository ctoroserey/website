<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Claudio Toro-Serey</title>
    <link>https://ctoroserey.netlify.com/post/</link>
    <description>Recent content in Posts on Claudio Toro-Serey</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 -0500</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Secret Santa Generator Shiny App</title>
      <link>https://ctoroserey.netlify.com/post/ssgnrtr/</link>
      <pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ctoroserey.netlify.com/post/ssgnrtr/</guid>
      <description>&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#why-are-you-doing-this-there-are-enough-secret-santa-services&#34;&gt;Why are you doing this? There are enough secret santa services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#so-how-does-it-work&#34;&gt;So, how does it work?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shiny-implementation&#34;&gt;Shiny implementation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#closing&#34;&gt;Closing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;why-are-you-doing-this-there-are-enough-secret-santa-services&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Why are you doing this? There are enough secret santa services&lt;/h2&gt;
&lt;p&gt;Last Christmas my wife was left giftless on my side of the family due to a faulty secret santa generator. In trying to earn brownie points the arrogant nerd in me thought he could do better, so I decided to program one in R (I’d rather know exactly what’s going on in the background anyways). I also found it hard this year to find a service that prevented specific pairs of people from gifting each other.&lt;/p&gt;
&lt;p&gt;But beyond my petty personal reasons, a friend suggested that this would be a good opportunity to learn how to build Shiny apps. So I’ll use this post to explain the basics of the code, and how you can turn it into a Shiny app (disclaimer: this being my first Shiny app means that the setup is crude, so I definitely recommend checking out the great official examples that Shiny provides).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Update 11/30/18: of course I found &lt;a href=&#34;https://blog.revolutionanalytics.com/2017/11/how-to-generate-a-secret-santa-list-with-r.html&#34;&gt;this blog post&lt;/a&gt; the day after I posted mine, which shows that the script and idea had been mostly done before by a combination of coders. Even some of the language that I have here ended up being too similar to what David writes, unfortunately. Even more, &lt;a href=&#34;https://www.tjmahr.com/secret-santa-graph-traversal/&#34;&gt;Tristan Mahr already solved the problem of pair constraints&lt;/a&gt; through a graph implementation that, while too busy for my taste and to implement in Shiny, made for a pretty cool post. Still, I’ll keep this up since there are some novel elements to the way I went about it (that I know of, at least), and I couldn’t find another Shiny app that did the trick.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;so-how-does-it-work&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;So, how does it work?&lt;/h2&gt;
&lt;p&gt;The setup is simple. Let’s look at the function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;xmaspairs &amp;lt;- function(Members = 1, Spouses = 1, Secret = T) {
  
  # Make sure that members were provided..
  if (length(Members) == 1) {stop(&amp;quot;No members indicated...&amp;quot;)}
  
  # If spouse pairing should be avoided..
  if (length(Spouses) == length(Members)) {
    
    # Make sure that a single group isn&amp;#39;t more than 50% of the members
    if(max(table(input$Spouses)) &amp;gt; length(input$Members)/2) {stop(&amp;quot;A group can&amp;#39;t be more than 50% of the total members...&amp;quot;)}
    
    # Iterate over possible pairings until no SOs are paired
    Affiliated &amp;lt;- T
    while (Affiliated) {
      m &amp;lt;- sample(Members)
      df &amp;lt;- data.frame(Member = m,
                       Gift_to = c(tail(m, n = 1), m[seq(length(m)-1)])) # sure there&amp;#39;s a better way to do this..
      Spouse1 &amp;lt;- Spouses[match(df$Member, Members)]
      Spouse2 &amp;lt;- Spouses[match(df$Gift_to, Members)]
      Affiliated &amp;lt;- T %in% (Spouse1 == Spouse2)
    }
  # Otherwise just produce whatever pairing comes out from a single sampling  
  } else { 
    m &amp;lt;- sample(Members)
    df &amp;lt;- data.frame(Member = m,
                     Pair = c(tail(m, n = 1), m[seq(length(m)-1)]))
  }
  
  # If the person running it should be blinded to the pairs, create individual txt files
  if (Secret) {
    for (i in seq(nrow(df))) {
      write.table(paste(&amp;quot;Your secret santa is: &amp;quot;, df[i, 2], &amp;quot;!&amp;quot;, sep = &amp;quot;&amp;quot;), 
                  file = paste(df[i,1],&amp;quot;.txt&amp;quot;, sep = &amp;quot;&amp;quot;),
                  row.names = F, 
                  col.names = F)
    }
  # or for groups who don&amp;#39;t care about social subtleties
  } else {
    return(df)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Basically, the function takes in a mandatory character vector of members, an optional grouping vector (either numeric of string), and the choice of whether to hide the final pairings from everyone. The way it works is simple: shuffle the members, then create a new vector with everyone shifted by 1 position (this is the equivalent of randomly sitting people in a circle and telling them to gift the person to their right).&lt;/p&gt;
&lt;p&gt;Now, if you wanted to prevent 2 members from gifting each other, all you do is feed a grouping vector into Spouses. So, let’s say you have Mom, Dad, Cindy, you, and Dormamu the Destroyer on your members list, and of course you don’t want your parents gifting each other. Then all you have to do is create a vector like &lt;code&gt;c(Parent, Parent, 1, 2, Immortal)&lt;/code&gt; to feed to the function. This will force the function to iterate through combinations of gifters/receivers until the pairs don’t share the same grouping characteristic. Note that since I use an equivalence, pretty much anything can be used as a grouping variable. If you don’t care about this, just write NA or anything that doesn’t match the length of the members list.&lt;/p&gt;
&lt;p&gt;Finally, if you select &lt;code&gt;Secret = T&lt;/code&gt; the function won’t generate a dataframe. Instead, it will download a text file for each member on your current directory, indicating to whom they should gift. I know it would be easier to email people rather than having to send them their text files manually, but I was a bit lazy and didn’t want to deal with SMTP setups.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;shiny-implementation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Shiny implementation&lt;/h2&gt;
&lt;p&gt;It might be helfpul to get acquainted with how everything looks before digging into the code. You can go ahead and play with the app if you’d like, or check it out &lt;a href=&#34;https://ctoroserey.shinyapps.io/SecretSantaGeneratR/&#34;&gt;online&lt;/a&gt;.&lt;/p&gt;
&lt;iframe width=&#34;100%&#34; height=&#34;900&#34; src=&#34;https://ctoroserey.shinyapps.io/SecretSantaGeneratR/&#34;&gt;
&lt;/iframe&gt;
&lt;p&gt;Alright then, how is it made?&lt;/p&gt;
&lt;p&gt;The core of a Shiny app is way simpler than I expected. You have three components: a &lt;code&gt;ui&lt;/code&gt; to dictate the arrangement of elements, a &lt;code&gt;server&lt;/code&gt; to produce its contents, and a simple &lt;code&gt;shinyApp&lt;/code&gt; function that brings these two together.&lt;/p&gt;
&lt;p&gt;This is what the &lt;code&gt;ui&lt;/code&gt; portion looks like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# ui &amp;lt;- fluidPage(
#   
#   titlePanel(&amp;quot;Secret Santa GeneratR&amp;quot;),
# 
#   p(&amp;quot;Welcome to yet another secret santa generator! The advantage of this one is that it gives you the option to keep the pairings secret or not, as well as avoiding pairs of people who should not gift each other! Perfect if you have inter-dimensional friends that can&amp;#39;t physically interact with each other.&amp;quot;),
#   
#   #Sidebar layout with input and output definitions ----
#   sidebarLayout(
# 
#     # Sidebar panel for inputs ----
#     sidebarPanel(
# 
#       # Input: Text for providing a caption ----
#       textInput(inputId = &amp;quot;Members&amp;quot;,
#                 label = &amp;quot;Group member names:&amp;quot;,
#                 value = &amp;quot;A, B, C, D, E, F&amp;quot;),
#       
#       # Explanation of spouse matching
#       p(&amp;quot;If you want to prevent specific pairs of people from gifting each other, write down some characteristic that pairs them below (in the order they&amp;#39;re written above). In the example below, A/B and C/D are part of &amp;#39;Couple&amp;#39; and &amp;#39;Couple2&amp;#39;, respectively, and won&amp;#39;t gift within couples; but E and F have their own group and can give/receive with anyone (note that the number of entries must match the number of members). Write &amp;#39;NA&amp;#39; if you don&amp;#39;t care about this.&amp;quot;),
#       
#       # Set pairs to avoid
#       textInput(inputId = &amp;quot;Spouses&amp;quot;,
#                 label = &amp;quot;Avoidance list:&amp;quot;,
#                 value = &amp;quot;Couple, Couple, Couple2, Couple2, S1, S2&amp;quot;),
#       
#      # Apply changes
#      submitButton(&amp;quot;Update List&amp;quot;),
#      
#      # Empty space
#      p(),
#
#       # Note on making it secret
#       p(&amp;quot;If you want to keep it secret, a file for each member will be created telling them who they should gift based on a new, unseen pairing. Just send each person their file!&amp;quot;),
#       
#       # and the respective download button for the zip file
#       downloadButton(&amp;quot;download&amp;quot;, &amp;quot;Make Secret&amp;quot;)
# 
#     ),
# 
#     # Main panel for displaying outputs ----
#     mainPanel(
# 
#       p(&amp;quot;Here are the current santa pairs. Note that if you click on &amp;#39;Make Secret&amp;#39; a completely new scheme will be produced that you won&amp;#39;t see here.&amp;quot;),
#       
#       # Output: HTML table with requested number of observations ----
#       tableOutput(&amp;quot;view&amp;quot;)
# 
#     )
#   )
# )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All we are doing here is defining what goes up top (&lt;code&gt;titlePanel&lt;/code&gt; and the first paragraph &lt;code&gt;p&lt;/code&gt;), which user inputs to place in the sidebar (&lt;code&gt;sidebarPanel&lt;/code&gt; within &lt;code&gt;sidebarLayout&lt;/code&gt;), and what goes on the main area of the site (&lt;code&gt;mainPanel&lt;/code&gt; within &lt;code&gt;sidebarLayout&lt;/code&gt;). Things to note here: functions like &lt;code&gt;textInput&lt;/code&gt; ask the user for input, and you give them IDs so you can call the values in the &lt;code&gt;server&lt;/code&gt; portion (see next). Here I place default values just to give the user an example. On the other hand, &lt;code&gt;tableOutput&lt;/code&gt; and &lt;code&gt;downloadButton&lt;/code&gt; seem to be getting input from somewhere (here “view” and “download”). These are output variables generated by the server! So all that’s happening is that the &lt;code&gt;ui&lt;/code&gt; passes on inputs that are then processed and returned by the &lt;code&gt;server&lt;/code&gt; to be placed on the GUI. That’s it.&lt;/p&gt;
&lt;p&gt;One last thing about &lt;code&gt;ui&lt;/code&gt; and Shiny in general: these widgets are reactive, meaning that they will update the output whenever any changes are made. This can be problematic, so we add a &lt;code&gt;submitButton&lt;/code&gt; called ‘Update List’ to apply the changes the user makes.&lt;/p&gt;
&lt;p&gt;Next, what does the &lt;code&gt;server&lt;/code&gt; look like?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# server &amp;lt;- function(input, output){
#   
#   
#   # Function that does the pairings
#   xmaspairs &amp;lt;- function(Members = 1, Spouses = 1, Secret = T) {
#     
#     # This crude function will pair group members for secret santa
#     # If your family would like to avoid pairing significant others,
#     # define Spouses to be a vector of groupings (i.e. numeric).
#     # The script will then iterate over pairings until no SOs are paired.
#     
#     # Perform the actual pairing
#     # If spouse pairing should be avoided..
#     if (length(Spouses) == length(Members)) {
#       # Once this turns false, we are in business
#       Affiliated &amp;lt;- T
#       # Iterate over possible pairings until no SOs are paired
#       while (Affiliated) {
#         m &amp;lt;- sample(Members)
#         df &amp;lt;- data.frame(Member = m,
#                          Gift_to = c(tail(m, n = 1), m[seq(length(m)-1)])) # sure there&amp;#39;s a better way to do this..
#         Spouse1 &amp;lt;- Spouses[match(df$Member, Members)]
#         Spouse2 &amp;lt;- Spouses[match(df$Gift_to, Members)]
#         Affiliated &amp;lt;- T %in% (Spouse1 == Spouse2)
#       }
#     # Otherwise just produce whatever pairing comes out from a single sampling  
#     } else { 
#       m &amp;lt;- sample(Members)
#       df &amp;lt;- data.frame(Member = m,
#                        Gift_to = c(tail(m, n = 1), m[seq(length(m)-1)]))
#     }
#     
#     # spit out the pairs
#     return(df)
#     
#   }
#   
#   
#   # Download a zip file with each pair 
#   output$download &amp;lt;- downloadHandler(
#     
#     # Name of the download
#     filename = function() {&amp;quot;SecretSantaPairs.zip&amp;quot;},
#     
#     # Prep the zip file 
#     content = function(file) { 
#       # Parse the strings
#       m &amp;lt;- unlist(strsplit(gsub(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;, input$Members, fixed=T), &amp;quot;,&amp;quot;))
#       s &amp;lt;- unlist(strsplit(gsub(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;, input$Spouses, fixed=T), &amp;quot;,&amp;quot;))
#       # Make sure the groupings don&amp;#39;t break the code by having a group be over 50% of members
#       validate(need(try(max(table(s)) &amp;lt; length(m)/2), &amp;quot;A group can&amp;#39;t have more than 50% of the members&amp;quot;))
#       #Pairing
#       df &amp;lt;- xmaspairs(Members = m, 
#                       Spouses = s)
#       # Write files per person indicating to whom they have to gift
#       owd &amp;lt;- setwd(tempdir()) # temporary dir to store the files
#       on.exit(setwd(owd))
#       files &amp;lt;- list()      
#       lapply(seq(nrow(df)), function(i) {
#         write.table(paste(&amp;quot;Your secret santa is: &amp;quot;, df[i, 2], &amp;quot;!&amp;quot;, sep = &amp;quot;&amp;quot;), 
#                     file = paste(df[i,1],&amp;quot;.txt&amp;quot;, sep = &amp;quot;&amp;quot;),
#                     row.names = F, 
#                     col.names = F)})
#       zip(file, paste(unlist(strsplit(gsub(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;, input$Members, fixed=T), &amp;quot;,&amp;quot;)), &amp;quot;.txt&amp;quot;, sep = &amp;quot;&amp;quot;)) # and zip
#     }
#     
#   )
#   
#   
#     # render the resulting table 
#   output$view &amp;lt;- renderTable({
#     
#       # Parse the strings
#       m &amp;lt;- unlist(strsplit(gsub(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;, input$Members, fixed=T), &amp;quot;,&amp;quot;))
#       s &amp;lt;- unlist(strsplit(gsub(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;, input$Spouses, fixed=T), &amp;quot;,&amp;quot;))
#       # Make sure that enough members are entered
#       validate(need(length(m) &amp;gt; 1, &amp;quot;Not enough members!&amp;quot;))
#       # Make sure the groupings don&amp;#39;t break the code by having a group be over 50% of members
#       validate(need(try(max(table(s)) &amp;lt;= length(m)/2), &amp;quot;A group can&amp;#39;t have more than 50% of the members&amp;quot;))
#       # Produce pairings to display
#       xmaspairs(Members = m, 
#                 Spouses = s,
#                 Secret = input$Secret)
#     
#   })
# }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You probably already saw that the &lt;code&gt;server&lt;/code&gt; function works with input and output, as we just discussed. The next thing you’ll see is a shortened version of the &lt;code&gt;xmaspairs&lt;/code&gt; function, but without the ability to download files. Why is that? Well, Shiny comes with a handy widget to download files, and this saves us the pain of asking the user to write down a local path that the app might not have access to. The way this works is that you’ll store what to return to the &lt;code&gt;ui&lt;/code&gt; in an &lt;code&gt;outputs&lt;/code&gt; list. First we define &lt;code&gt;outputs$download&lt;/code&gt; (this is the “download” that gets passed onto &lt;code&gt;downloadButton&lt;/code&gt; in the &lt;code&gt;ui&lt;/code&gt; above). This widget requires you to define the &lt;code&gt;filename&lt;/code&gt; (“SecretSantaPairs.zip”) and the &lt;code&gt;content&lt;/code&gt;. Within &lt;code&gt;content&lt;/code&gt; you can write whatever code will generate the information that you want the user to download. All I did here was to run the file-writing part of my original function separately from creating the pairs, storing the files on a temporary directory, and compressing them into a single zip file that will be downloaded (this is because &lt;code&gt;downloadButton&lt;/code&gt; can only handle one file at a time). Note that &lt;code&gt;xmaspairs&lt;/code&gt; takes in the &lt;code&gt;ui&lt;/code&gt; values contained within the &lt;code&gt;inputs&lt;/code&gt; list (with the IDs that we defined above as the variable names). This is a cleaner way to cue the user to produce a secret listing.&lt;/p&gt;
&lt;p&gt;At the end of server you’ll find &lt;code&gt;renderTable&lt;/code&gt; being stored within &lt;code&gt;output$view&lt;/code&gt; (yes, the “view” that’s used in the &lt;code&gt;ui&lt;/code&gt;). This will show a table with the pairings according to the conditions specified. This will always appear (even if we click the download button), but note that since pressing the button generates an independent list, the user is still technically blinded from knowing who got who. Also worth noting is that I used &lt;code&gt;validate(need())&lt;/code&gt; to send out an error message to the user if either not enough members were entered, or if too many members were grouped together. If you use R’s classic &lt;code&gt;stop&lt;/code&gt;, Shiny will throw an ugly crashing error once published.&lt;/p&gt;
&lt;p&gt;Ok, now that we set up our interacting &lt;code&gt;server&lt;/code&gt; and &lt;code&gt;ui&lt;/code&gt; we can put them together. All you need to do is run&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# library(shiny)
# shinyApp(ui = ui, server = server) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will open a new window with your app! (normally you put all these elements within the same file: app.R) This will also give you the option to publish you app to &lt;a href=&#34;https://www.shinyapps.io&#34;&gt;shinyapps.io&lt;/a&gt; by clicking ‘publish’ on your pop-up window. Of course this requires registering for an account there, but otherwise Shiny makes it seemless to upload your app so you can share it with everyone!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;closing&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Closing&lt;/h2&gt;
&lt;p&gt;There are enough great tutorials on how to build Shiny apps, but I hope this will be useful for someone. If anything, there is one thing I would like whoever reads this to know: &lt;em&gt;You don’t need an extravagant project to try something new.&lt;/em&gt; If you would like to play with the code, it’s available on &lt;a href=&#34;https://github.com/ctoroserey/SS_GeneratR&#34;&gt;my GitHub site&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Cluster comparisons with ARI</title>
      <link>https://ctoroserey.netlify.com/post/ari/</link>
      <pubDate>Wed, 26 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ctoroserey.netlify.com/post/ari/</guid>
      <description>&lt;script src=&#34;https://ctoroserey.netlify.com/rmarkdown-libs/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#a-bit-of-background&#34;&gt;A bit of background&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-rand-index&#34;&gt;The Rand Index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-adjusted-rand-index&#34;&gt;The Adjusted Rand Index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#closing&#34;&gt;Closing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;a-bit-of-background&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;A bit of background&lt;/h2&gt;
&lt;p&gt;A common need for researchers that rely on clustering algorithms, such as the organization of networks into cohesive node communities, is to evaluate the similarity of the partitions produced. In my case this problem takes the form of comparing the distribution of brain networks across individuals. While many tools have been developed to tackle the challenge (see Fortunato &amp;amp; Hric, 2016 for an initial survey), here I’ll give a superficial view on the adjusted rand index (ARI), hoping to better understand its behavior and ideal case usage. Since I’m more familiar with the usage of this measure in networks, I’ll base my terminology on this framework.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-rand-index&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The Rand Index&lt;/h2&gt;
&lt;p&gt;The original Rand Index (RI) was introduced by William Rand in 1975, and it aimed to determine whether two clustering algorithms grouped every pair of nodes in a similar fashion. For example, it could be that nodes 3 and 25 from your network were grouped together in partitions from algorithms A and B, but separately by method C (you can probably already think of uses for this index in regards to examining the effects of experimental network perturbations in their organization). This agreement is computed by the following simple formula:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\frac{a + b}{a + b + c + d}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; is the number of pairs of nodes that were grouped together in both partitions, &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; is the number that were grouped separately, and &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; denote the number grouped together (separately) in one partition, but separately (together) in the other. In short, the Rand Index just gives the proportion of nodes equally paired in both partitions.&lt;/p&gt;
&lt;p&gt;At this point you might have already thought: what is the advantage of doing this instead of directly checking if the node labels are identical across partitions? (i.e. &lt;code&gt;partitionA == partitionB&lt;/code&gt;) For some of us the answer is not quite evident, which is what motivated me to write this post. To begin exploring this, let’s look at a toy example of two hypothetical binary clustering algorithms (A and B) applied to a small network (I will mainly focus on this type of classification for simplicity):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Toy clusterings
table &amp;lt;- data.frame(A = c(1,1,1,0,0),
                    B = c(0,0,0,1,1))

# Output table
table %&amp;gt;% 
  knitr::kable(&amp;quot;html&amp;quot;) %&amp;gt;%
  kable_styling(full_width = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table&#34; style=&#34;width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
A
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
B
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Compute agreement (arandi comes from the package &amp;#39;mcclust&amp;#39;)
EQ &amp;lt;- mean(table$A == table$B)
RI &amp;lt;- arandi(table$A, table$B, adjust = F)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, a simple equivalence (EQ) would of course yield a value of 0, as none of the values match. On the other hand, RI yields a value of 1. This is because the relationship among all nodes remains unchanged across partitions. This portrays the first advantage of metrics like RI: &lt;em&gt;they evaluate the underlying relationship among your clustered nodes while being agnostic to the labeling system.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Now let’s tweak the clusters a bit, so that there is one rogue node that switches clusters.&lt;/p&gt;
&lt;table class=&#34;table&#34; style=&#34;width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
A
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
B
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In this case, checking the equivalence of the vectors yields 0.8, while the Rand Index gives 0.6. This is because RI doubles the dimensionality by considering the underlying interconnectedness of the nodes, such that the total number of pairwise combinations becomes &lt;code&gt;factorial(5) / (factorial(2) * factorial(5-2))&lt;/code&gt;, or 10. By changing the allegiance of a single node, we basically change the interaction of that node with the other four members, giving us an agreement level between partitions of &lt;code&gt;6/10&lt;/code&gt; (i.e., the RI value we got). To clarify this idea, let’s now suppose that cluster labels can be 0, 1, or 2, with the rogue node now being part of 2:&lt;/p&gt;
&lt;table class=&#34;table&#34; style=&#34;width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
A
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
B
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
2
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In this case, both the vector equivalence and RI give the same value (0.8). This is because the rogue node was originally tied to two others in cluster 0, whereas its unrelatedness to cluster 1 remains unchanged (unlike before, where it became part of it). This now gives a ratio of similarities of &lt;code&gt;8/10&lt;/code&gt;. Hopefully this provides a better sense of the advantages of RI over simple equivalence, especially once you increase both the number of nodes and clusters.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-adjusted-rand-index&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The Adjusted Rand Index&lt;/h2&gt;
&lt;p&gt;So far so good, but as researchers we always want to control for the possibility that our results are defined by chance! That’s where the adjustment to RI introduced by Hubert &amp;amp; Arabie (1985) comes in. The Adjusted Rand Index controls for the expected distribution of labels given by chance, and compares the original RI to this random model–while still guaranteeing that perfect clustering matches get a value of 1. &lt;a href=&#34;https://davetang.org/muse/2017/09/21/adjusted-rand-index/&#34;&gt;Others have already done a great job in explaining the mathematical nuances of the ARI&lt;/a&gt;, so I will instead focus on understanding how the three metrics (i.e. EQ, RI, and ARI) behave under similar circumstances.&lt;/p&gt;
&lt;p&gt;Let’s say we have an original vector of 100 nodes classified as part of either cluster 1 or 0. I will progressively switch the allegiance of each node, and on each case I will estimate the agreement between the new vector and the original one. In other words, I will check the values given by these metrics as the modified vector slowly becomes more disimilar from the original one. The plot summarizes the results.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Produce a random vector with 100 binary classifications
n &amp;lt;- 100
v1 &amp;lt;- rbinom(n = n, size = 1, prob = 0.5)

# Data frame to store evaluations
evals &amp;lt;- data.frame(Diffs = seq(n),
                    ARI = rep(0,n),
                    RI = rep(0,n),
                    EQ = rep(0,n))

# Check the degree of agreement per metric for each incremental switch in affiliation
for (i in seq(n)) {
  
  # Switch affiliation up to the ith node
  ifelse(i &amp;lt; n, v2temp &amp;lt;- c((1 - v1[seq(i)]), v1[(i+1):n]), v2temp &amp;lt;- v1)
  
  # Evaluate
  evals$ARI[i] &amp;lt;- arandi(v1,v2temp)
  evals$RI[i] &amp;lt;- arandi(v1,v2temp, adjust = F)
  evals$EQ[i] &amp;lt;- mean(v1 == v2temp)
  
}

# Make the data.frame long instead of wide for ggplot
evals &amp;lt;- melt(evals[seq(n-1),], id.vars = &amp;quot;Diffs&amp;quot;)

# And plot
ggplot(data = evals, aes(Diffs, value, group = variable, color = variable)) + 
  geom_line() +
  scale_color_discrete(name = &amp;quot;Method&amp;quot;) +
  theme_classic()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://ctoroserey.netlify.com/post/2018-09-26-ARI_files/figure-html/Compute-1.svg&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So, progressively switching the affiliations of the original vector has the expected negative linear trend on EQ, as the vectors become increasingly dissimilar. On the other hand, RI heavily penalises initial clustering disagreements, but notice that once the differences pass 50% the vectors are deemed increasingly similar. This parabolic function is a result of node pairs once again being grouped in the same/different clusters once direct differences pass chance levels (think back to the first example, and how inverting the values still maintains the underlying relationships). Finally, we can see that ARI drops to 0 when the vector differences reach this chance level. In accord with its definition, positive ARI values thus denote agreements above those expected by chance&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;closing&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Closing&lt;/h2&gt;
&lt;p&gt;As I said in the introduction, I use the ARI to check how similar the distribution of functional brain networks is across individuals. However, you could imagine using this metric as a way to evaluate the accuracy of neural nets as they are being trained (provided that you have the ground truth of what’s being clustered). It is also worth mentioning that the ARI is not the ultimate way to evaluate clusterings. As Fortunato &amp;amp; Hric (2016) discuss, metrics based on mutual information tend to be more robust (i.e. variation of information), and are also included in statistical packages (like mcclust for R, which I use here).&lt;/p&gt;
&lt;p&gt;Regardless, I hope this can eventually be as useful for someone to read as it was for me to write it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;If you are interested in getting the statistical significance of this deviation from chance, see Fortunato &amp;amp; Hric (2016) who discuss the computation of Z-scores based on permutations. I might expand this post in the future to show how this works.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A short introduction</title>
      <link>https://ctoroserey.netlify.com/post/getting-started/</link>
      <pubDate>Wed, 20 Apr 2016 00:00:00 -0400</pubDate>
      
      <guid>https://ctoroserey.netlify.com/post/getting-started/</guid>
      <description>&lt;p&gt;In a way, this is just a post to baptise the website. What I plan to do here from now on is to share snippets of what I&amp;rsquo;ve learned, read, or listened to lately (with a small dose of personal experiences), in hopes to both consolidate my knowledge and potentially help others. In a way, the picture of Boston in the header just represents that the overarching theme will be anything that has happened since I moved here for grad school (so yes, learning, reading, and listening to music mostly).&lt;/p&gt;

&lt;p&gt;Nothing too serious or big, just fun.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
